let instanceParser = {};

onmessage = function (event) {
    instanceParser = new AJAXParser(event.data.meta, event.data.session, event.data.misc);
    instanceParser.rawParse(event.data.input)
        .then(data => {
            postMessage(data);
        });
};

class AJAXParser {
    constructor(meta = {}, session = {}, misc = { xpostMentions: [] }) {
        /**
         * Holders for additional information generated by loadHandlers.
         * @type {{}}
         */
        this.meta = meta;
        this.session = session;
        this.misc = misc;
    }

    getLoadType(rawCommand) {
        let loadTypes = [];

        for (let key in loadHandler) {
            if (loadHandler.hasOwnProperty(key)) {
                if (!loadHandler[key].filter) continue;
                if (~rawCommand.indexOf(loadHandler[key].filter)) loadTypes.push(key);
            }
        }

        return loadTypes[0] || 'reddit';
    }

    rawParse(input) {
        this.session.rawCommand = input;
        const commandArray = input.split(' ');
        commandArray[0] = commandArray[0].toLowerCase();
        return this.rawLoadAdapter(commandArray, this.getLoadType(input));
    }

    rawLoadAdapter(inputArray, loadType) {

        const loadVariables = loadHandler[loadType].method(inputArray);

        return new Promise((resolve, reject) => {

            this.instanceReaver = new AJAXReaver(
                loadVariables.url,
                loadVariables.data || false,
                loadVariables.dataType
            );

            this.instanceReaver.promise
                .then(data => {
                    resolve({
                        data: this.rawJsonParseAdapter(JSON.parse(data), loadVariables.additionalData, loadType),
                        misc: this.misc,
                        meta: this.meta,
                        session: this.session,
                        finished: true,
                        status: 4
                    });
                })
                .catch(reject);

        });
    }

    rawJsonParseAdapter(inputJSON, additionalData, parseType) {
        const parsedJSON = jsonParseHandler[parseType](inputJSON, additionalData);
        if (!parsedJSON.length) return false;

        let returnArray = [];
        for (let i = 0, len = parsedJSON.length; i < len; i++) {
            const parsedUrl = detectUrl(parsedJSON[i].url, parsedJSON[i].metadata, false);
            if (parsedUrl !== 'error') returnArray.push(parsedUrl);
        }

        return returnArray;
    }
}

class AJAXReaver {
    constructor(url, data = {}, type = 'json') {

        this.promise = new Promise((resolve, reject) => {
            this.onResolve = resolve;
            this.onReject = reject;
        });

        /**
         * We need the constructor to return before doing this, because the JSONP
         * Callback in the global namespace (of this worker runtime) has to access
         * instanceParser.instanceReaver.onResolve.
         */
        setTimeout(() => {
            if (type === 'json') {
                this.doXHRCall(url, data);
            } else if (type === 'jsonp') {
                this.doJSONPCall(url, data);
            }
        }, 1);
    }

    doXHRCall(url, data, type = 'GET') {
        let req = new XMLHttpRequest();
        req.open(type, url);
        req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        req.onreadystatechange = () => {
            postMessage({
                finished: false,
                status: req.readyState,
                code: req.status,
                type: 'xhr'
            });
            if (req.readyState === 4 && req.status === 200) {
                this.onResolve(req.responseText);
            }
        };
        req.send(AJAXReaver.getDataString(data));

        return req;
    }

    doJSONPCall(url, data) {
        const antiCache = Math.round(100000 * Math.random());
        postMessage({
            finished: false,
            status: 2,
            code: 200,
            type: 'jsonp'
        });
        importScripts(`${url}${url.indexOf('?') >= 0 ? '&' : '?'}callback=jsonpCallbackHandler&antiCache=${antiCache}&${AJAXReaver.getDataString(data)}`);
    }

    static getDataString(data) {
        let dataArray = [], key;

        for (key in data) {
            dataArray.push(`${key}=${data[key]}`);
        }

        return dataArray.join("&");
    }
}

function jsonpCallbackHandler(data) {
    instanceParser.instanceReaver.onResolve(JSON.stringify(data));
}

/* ----- Rendering and Data Translation ----- */

// LoadHandlers take the input and prepare several variables for loading
const loadHandler = {

    reddit: {

        filter: false,
        name: "reddit",
        description: "Shows all images on the front page of the specified subreddit. Supports loading subsequent pages, and filters that can be appended to the Subreddit, separated by a space. Usage example: 'earthporn 4'",

        method: function (inputArray) {
            instanceParser.meta.subreddit = inputArray[0];
            var sortFilter = inputArray[1] || 0;

            switch (Number(sortFilter)) {
                case 1:
                    instanceParser.meta.sort = "/top.json?sort=top&t=all";
                    instanceParser.meta.mode = "top - ever";
                    break;
                case 2:
                    instanceParser.meta.sort = "/top.json?sort=top&t=year";
                    instanceParser.meta.mode = "top - year";
                    break;
                case 3:
                    instanceParser.meta.sort = "/top.json?sort=top&t=month";
                    instanceParser.meta.mode = "top - month";
                    break;
                case 4:
                    instanceParser.meta.sort = "/top.json?sort=top&t=week";
                    instanceParser.meta.mode = "top - week";
                    break;
                default:
                    instanceParser.meta.sort = "/hot.json?bagool=1";
                    instanceParser.meta.mode = "hot";
                    break;
            }

            instanceParser.meta.subreddit = instanceParser.meta.subreddit.replace("/r/", "");
            var rawInput = instanceParser.session.rawCommand.replace("/r/", "");

            var docTitle = instanceParser.meta.subreddit + " - Grid";
            var redditUrl = "https://www.reddit.com/r/" + instanceParser.meta.subreddit + instanceParser.meta.sort;

            // Check if it's a multireddit
            if (~instanceParser.meta.subreddit.indexOf("/m/")) {
                instanceParser.meta.subreddit = instanceParser.meta.subreddit.replace("/user/", "").replace("/u/", "");
                redditUrl = "https://www.reddit.com/user/" + instanceParser.meta.subreddit + instanceParser.meta.sort;
                docTitle = instanceParser.meta.subreddit + " - Grid";
            }

            var endPanels = [{
                onclick: 'extendPage()',
                html: 'Continue<br>Page ' + (instanceParser.meta.page + 2) + '<br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + instanceParser.meta.subreddit
            }];

            if (instanceParser.meta.mode != 'top - ever') {
                endPanels.push({
                    onclick: "executeCommand('" + instanceParser.meta.subreddit + " 1')",
                    html: 'Switch to <br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + instanceParser.meta.subreddit + '<br>top - ever'
                });
            } else {
                endPanels.push({
                    onclick: "executeCommand('" + instanceParser.meta.subreddit + " 4')",
                    html: 'Switch to <br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + instanceParser.meta.subreddit + '<br>top - week'
                });
            }

            return {
                url: redditUrl,
                rawinput: rawInput,
                docTitle: docTitle,
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">/r/</span>' + instanceParser.meta.subreddit + '<br><br>' + instanceParser.meta.mode + '</div>',
                additionalData: {},
                favorite: {
                    name: instanceParser.meta.subreddit,
                    type: 1
                },
                panels: endPanels,
                postRenderCards: true,
                dataType: "json"
            }
        },

        getPostRenderCards: function (callback) {
            const additionalCards = [];

            // Suggest Mentioned Subreddits - "Mentioned here"
            for (var i = instanceParser.misc.xpostMentions.length - 1; i >= 0; i--) {

                additionalCards.push({
                    onclick: "executeCommand('" + instanceParser.misc.xpostMentions[i] + "')",
                    html: 'Mentioned here<br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + instanceParser.misc.xpostMentions[i]
                });

            }

            // Suggest Popular Subreddits - "Recommended"
            // TODO
            /*
            if (settings.showNSFW && instanceParser.meta.isNSFW) {
                var recommendationArray = recommendationsNsfw;
            } else {
                var recommendationArray = recommendationsSfw;
            }

            for (var i = getRandomInt(1, 2); i >= 0; i--) {
                var randomRecommendation = recommendationArray[Math.floor(Math.random() * recommendationArray.length)];

                additionalCards.push({
                    onclick: "executeCommand('" + randomRecommendation + "')",
                    html: 'Recommended<br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + randomRecommendation
                });
            }
            */

            // Suggest Related Subreddits - "Also try"
            // TODO
            /*
             var relatedRedditJSON = $.getJSON("https://www.reddit.com/subreddits/search.json", {
             q: instanceParser.meta.subreddit,
             limit: 4
             }, function() {
             var relatedRedditNames = [];
             for (var i = relatedRedditJSON.responseJSON.data.children.length - 1; i >= 0; i--) {
             if (relatedRedditJSON.responseJSON.data.children[i].data.display_name.toLowerCase() != instanceParser.meta.subreddit.toLowerCase()) {
             relatedRedditNames.push(relatedRedditJSON.responseJSON.data.children[i].data.display_name);
             }
             }
             for (var i = relatedRedditNames.length - 1; i >= 0; i--) {
             additionalCards.push({
             onclick: "executeCommand('" + relatedRedditNames[i] + "')",
             html: 'Also try<br><span style="color: ' + getRandomColor() + ';" class="prefixspan">/r/</span>' + relatedRedditNames[i]
             });

             }

             callback(additionalCards);
             });
             */
        }

    },

    voat: {
        filter: "voat/",
        name: "voat",
        description: "Shows the images on the frontpage of a given voat subverse. Usage example: 'voat/books'",
        method: function (inputArray) {

            var voatSubverse = inputArray[0].split('/')[1];

            return {
                url: "https://cors.io?u=https://voat.co/api/subversefrontpage?subverse=" + voatSubverse,
                rawinput: "voat/" + voatSubverse,
                docTitle: "/v/" + voatSubverse + " - Grid",
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">/v/</span>' + voatSubverse + '</div>',
                dataType: 'json',
                additionalData: {}
            }

        }
    },

    fullchanCatalog: {

        filter: "8chan/",
        name: "fullchanCatalog",
        description: "Shows all threads with their main image and title. Allows accessing the viewed thread by pressing N in the slideshow. Usage example: '8chan/b/'",

        method: function (inputArray) {

            var chanBoard = inputArray[0].split('/')[1];

            return {
                url: "https://8ch.net/" + chanBoard + "/catalog.json",
                rawinput: "8chan/" + chanBoard + "/",
                docTitle: "/" + chanBoard + "/ Catalog - Grid",
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">/' + chanBoard + '/</span> Catalog</div>',
                additionalData: {
                    chanBoard: chanBoard
                },
                dataType: "json"
            }

        }

    },

    fullchan: {

        filter: "8ch.net",
        name: "fullchan",
        description: "Shows all images posted in a thread. Usage example: Simply enter the full URL of a thread.",

        method: function (inputArray) {

            var chan = {
                rawUrl: inputArray[0]
            };

            if (~chan.rawUrl.indexOf("http")) {
                // Raw URL
                chan.urlObject = new URL(chan.rawUrl);
                chan.thread = chan.urlObject.pathname.slice(0, -5);
                chan.board = chan.urlObject.pathname.split("/")[1];
            } else {
                // Stylized URL
                chan.pathArray = chan.rawUrl.split("/");
                chan.thread = chan.rawUrl.replace('8ch.net', '');
                chan.board = chan.pathArray[1];
            }

            return {
                url: "https://8ch.net/" + chan.thread + ".json",
                rawinput: "8ch.net" + chan.thread,
                docTitle: "/" + chan.board + "/ Thread - Grid",
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">/' + chan.board + '/</span> Thread</div>',
                additionalData: {
                    chanBoard: chan.board
                },
                dataType: "json"
            }
        }

    },

    halfchanCatalog: {

        filter: "4chan/",
        name: "halfchanCatalog",
        description: "Shows all threads with their main image and title. Allows accessing the viewed thread by pressing N in the slideshow. Usage example: '4chan/b/'",

        method: function (inputArray) {

            var chanBoard = inputArray[0].split('/')[1];

            return {
                url: "https://cors-anywhere.herokuapp.com/https://a.4cdn.org/" + chanBoard + "/catalog.json",
                rawinput: "4chan/" + chanBoard + "/",
                docTitle: "4/" + chanBoard + "/ Catalog - Grid",
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">4/' + chanBoard + '/</span> Catalog</div>',
                additionalData: {
                    chanBoard: chanBoard
                },
                dataType: "json"
            }

        }

    },

    halfchan: {

        filter: "4chan.org",
        name: "halfchan",
        description: "Shows all images posted in a thread. Usage example: Simply enter the full URL of a thread.",

        method: function (inputArray) {

            var chan = {
                rawUrl: inputArray[0]
            };

            if (~chan.rawUrl.indexOf("http")) {
                // Raw URL
                chan.pathArray = new URL(chan.rawUrl).pathname.split("/");
                chan.board = chan.pathArray[1];
                chan.thread = chan.pathArray[3];
            } else {
                // Stylized URL
                chan.pathArray = chan.rawUrl.split("/");
                chan.board = chan.pathArray[1];
                chan.thread = chan.pathArray[2];
            }

            return {
                url: "https://cors-anywhere.herokuapp.com/https://a.4cdn.org/" + chan.board + "/thread/" + chan.thread + ".json",
                rawinput: "4chan.org/" + chan.board + "/" + chan.thread + "/",
                docTitle: "4/" + chan.board + "/ Thread - Grid",
                loadString: '<div id="loader">Loading <span style="color: ' + getRandomColor() + '" class="prefixspan">4/' + chan.board + '/</span> Thread</div>',
                additionalData: {
                    chanBoard: chan.board
                },
                dataType: "json"
            }
        }

    },

    tumblr: {
        filter: ".tumblr",
        name: "tumblr",
        description: "Shows all 'photo posts' on the first page of the specified blog. Supports loading subsequent pages. Usage example: Simply enter the full URLs, but it can be reduced to 'user.tumblr'",

        method: function (inputArray) {
            var tumblrUrl = inputArray[0];

            if (~tumblrUrl.indexOf(".com")) {
                // Extract the Tumblr username from the URL
                var tumblrBlog = new URL(tumblrUrl).hostname.split(".")[0];
            } else {
                // Or just clean up the input manually
                var tumblrBlog = tumblrUrl.replace(".tumblr", "");
            }

            if (~tumblrBlog.indexOf(".")) {
                var instTumblrSplit = tumblrBlog.split(".");
                tumblrBlog = instTumblrSplit[instTumblrSplit.length - 1];
            }

            return {
                url: 'https://api.tumblr.com/v2/blog/' + tumblrBlog + '.tumblr.com/posts/photo?api_key=Y0lYJX4ung4TrdRzSDBGNzfUZInCBwigE4IXSq0VakTGddp9vs',
                rawinput: tumblrBlog + '.tumblr',
                docTitle: tumblrBlog + '.tumblr - Grid',
                loadString: '<div id="loader">Loading ' + tumblrBlog + '<span style="color: ' + getRandomColor() + '" class="prefixspan">.tumblr</span></div>',
                additionalData: {
                    tumblr: tumblrBlog
                },
                favorite: {
                    name: tumblrBlog + '.tumblr',
                    type: 2
                },
                panels: [{
                    onclick: 'extendPage()',
                    html: 'Continue<br>Page ' + (instanceParser.meta.page + 2) + '<br>' + tumblrBlog + '<span style="color: ' + getRandomColor() + ';" class="prefixspan">.tumblr</span>'
                }],
                dataType: "jsonp"
            }
        }
    }

};

// JSONParsers take the received JSON and translate the data
const jsonParseHandler = {

    voat: function (inputJSON, additionalData) {
        var parsedReturn = [];

        for (let key in inputJSON) {
            if (inputJSON.hasOwnProperty(key)) {

                if (!inputJSON[key].MessageContent) continue;

                parsedReturn.push({
                    url: inputJSON[key].MessageContent,
                    metadata: {
                        title: inputJSON[key].Linkdescription,
                        author: inputJSON[key].name,
                        thumbUrl: 'https://cdn.voat.co/thumbs/' + inputJSON[key].thumbnail,
                        age: timeSinceDate(new Date(inputJSON[key].Date))
                    }
                });
            }
        }

        return parsedReturn;
    },

    fullchanCatalog: function(inputJSON, additionalData) {
        var parsedReturn = [];

        $.each(inputJSON, function(i, obj) {

            // We only read the first five pages here
            if (i === 5) return false;

            $.each(obj.threads, function(j, thread) {

                if (thread.tim && thread.tim.length <= 16) {
                    // Legacy image
                    var urlPrefix = "https://8ch.net/" + additionalData.chanBoard + "/src/";
                    var thumbPrefix = "https://media2.8ch.net/" + additionalData.chanBoard + "/thumb/";
                } else {
                    // New CDN image
                    var urlPrefix = "https://media.8ch.net/file_store/";
                    var thumbPrefix = "https://media.8ch.net/file_store/thumb/";
                }

                parsedReturn.push({
                    url: urlPrefix + thread.tim + thread.ext,
                    metadata: {
                        title: thread.sub || "(no subject)",
                        author: thread.name,
                        access: "8ch.net/" + additionalData.chanBoard + "/res/" + thread.no,
                        thumbUrl: thumbPrefix + thread.tim + ".jpg", // pngs are still parsed, this way we don't have to catch webm/mp4
                        age: timeSince(thread.time),
                        extended: {
                            replies: thread.replies,
                            images: Math.round(thread.omitted_images * 1.05), // To roughly make up for the non-omitted part
                            link: "/" + additionalData.chanBoard + "/" + thread.no
                        }
                    }
                });

            });

        });

        return parsedReturn;

    },

    fullchan: function(inputJSON, additionalData) {
        var parsedReturn = [];

        for (var i = 0; i <= (inputJSON.posts.length - 1); i++) {
            if (inputJSON.posts[i].tim) {

                if (inputJSON.posts[i].tim.length <= 16) {
                    // Legacy image
                    var urlPrefix = "https://8ch.net/" + additionalData.chanBoard + "/src/";
                    var thumbPrefix = "https://media2.8ch.net/" + additionalData.chanBoard + "/thumb/";
                } else {
                    // New CDN image
                    var urlPrefix = "https://media.8ch.net/file_store/";
                    var thumbPrefix = "https://media.8ch.net/file_store/thumb/";
                }

                parsedReturn.push({
                    url: urlPrefix + inputJSON.posts[i].tim + inputJSON.posts[i].ext,
                    metadata: {
                        title: inputJSON.posts[i].filename,
                        author: inputJSON.posts[i].name,
                        thumbUrl: thumbPrefix + inputJSON.posts[i].tim + ".jpg",
                        age: timeSince(inputJSON.posts[i].time)
                    }
                });

                if (inputJSON.posts[i].extra_files) {

                    for (var j = 0, len = inputJSON.posts[i].extra_files.length; j < len; j++) {

                        parsedReturn.push({
                            url: urlPrefix + inputJSON.posts[i].extra_files[j].tim + inputJSON.posts[i].extra_files[j].ext,
                            metadata: {
                                title: inputJSON.posts[i].extra_files[j].filename,
                                author: inputJSON.posts[i].name,
                                thumbUrl: thumbPrefix + inputJSON.posts[i].extra_files[j].tim + ".jpg",
                                age: timeSince(inputJSON.posts[i].time)
                            }
                        });

                    }

                };
            }
        };

        return parsedReturn;
    },

    halfchanCatalog: function (inputJSON, additionalData) {
        var parsedReturn = [];

        for (let key in inputJSON) {
            if (inputJSON.hasOwnProperty(key)) {

                // We only read the first two pages here
                if (key === 2) break;

                for (let threadKey in inputJSON[key].threads) {
                    if (inputJSON[key].threads.hasOwnProperty(threadKey)) {

                        let thread = inputJSON[key].threads[threadKey];
                        parsedReturn.push({
                            url: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + thread.tim + thread.ext,
                            metadata: {
                                title: thread.sub || "(no subject)",
                                author: thread.name,
                                access: "4chan.org/" + additionalData.chanBoard + "/" + thread.no,
                                thumbUrl: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + thread.tim + "s.jpg",
                                age: timeSince(thread.time),
                                extended: {
                                    replies: thread.replies,
                                    images: Math.round(thread.omitted_images * 1.05), // To roughly make up for the non-omitted part
                                    link: "/" + additionalData.chanBoard + "/" + thread.no
                                }
                            }
                        });

                    }
                }
            }
        }

        return parsedReturn;

    },

    halfchan: function (inputJSON, additionalData) {
        var parsedReturn = [];

        for (var i = 0; i <= (inputJSON.posts.length - 1); i++) {
            if (inputJSON.posts[i].tim) {

                parsedReturn.push({
                    url: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + inputJSON.posts[i].tim + inputJSON.posts[i].ext,
                    metadata: {
                        title: inputJSON.posts[i].filename,
                        author: inputJSON.posts[i].name,
                        thumbUrl: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + inputJSON.posts[i].tim + "s.jpg",
                        age: timeSince(inputJSON.posts[i].time)
                    }
                });

                if (inputJSON.posts[i].extra_files) {

                    for (var j = 0, len = inputJSON.posts[i].extra_files.length; j < len; j++) {

                        parsedReturn.push({
                            url: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + inputJSON.posts[i].extra_files[j].tim + inputJSON.posts[i].extra_files[j].ext,
                            metadata: {
                                title: inputJSON.posts[i].extra_files[j].filename,
                                author: inputJSON.posts[i].name,
                                thumbUrl: "https://i.4cdn.org/" + additionalData.chanBoard + "/" + inputJSON.posts[i].extra_files[j].tim + "s.jpg",
                                age: timeSince(inputJSON.posts[i].time)
                            }
                        });

                    }

                }
                ;
            }
        }
        ;

        return parsedReturn;
    },

    tumblr: function (inputJSON, additionalData) {
        var parsedReturn = [];

        instanceParser.meta.pageLoadPossible = true;

        for (var i = 0; i <= (inputJSON.response.posts.length - 1); i++) {
            var imageArray = inputJSON.response.posts[i].photos;
            var newTitle = inputJSON.response.posts[i].slug.split('-').join(' ');

            for (var j = 0; j <= imageArray.length - 1; j++) {
                var newImage = imageArray[j].original_size.url;

                parsedReturn.push({
                    url: newImage,
                    metadata: {
                        title: newTitle
                    }
                });
            }
        }

        return parsedReturn;
    },

    reddit: function (inputJSON, additionalData) {
        instanceParser.session.lastUrl = inputJSON.data.after;
        var parsedReturn = [];

        for (var i = 0; i <= (inputJSON.data.children.length - 1); i++) {

            var postTitle = inputJSON.data.children[i].data.title;

            if (inputJSON.data.children[i].data.over_18 && !instanceParser.meta.isNSFW) instanceParser.meta.isNSFW = true;

            // X-Post Scan
            if (~postTitle.indexOf('r/')) {
                var xpostName = postTitle.substr((postTitle.indexOf('r/') + 2), 999);
                xpostName = xpostName.split(' ')[0].split(')')[0].split(']')[0].replace(/\W/g, '');

                if (xpostName != instanceParser.meta.subreddit) {
                    instanceParser.misc.xpostMentions.push(xpostName);
                }
                ;
            }

            // Unused Feature
            // TODO
            /*
            if (inputJSON.data.children[i].data.selftext) {
                var selfTextUrlArray = extractLinksFromText(inputJSON.data.children[i].data.selftext);
                if (selfTextUrlArray.length) {
                    instanceParser.misc.selfpostURLs[inputJSON.data.children[i].data.id] = selfTextUrlArray;
                }
            }
            */

            parsedReturn.push({
                url: inputJSON.data.children[i].data.url,
                metadata: {
                    title: postTitle,
                    thumbUrl: inputJSON.data.children[i].data.thumbnail,
                    score: inputJSON.data.children[i].data.score,
                    author: inputJSON.data.children[i].data.author,
                    age: timeSinceDate(inputJSON.data.children[i].data.created_utc + '000')
                }
            });
        }

        instanceParser.meta.pageLoadPossible = true;
        return parsedReturn;
    }

};

/**
 * Remember, seperate runtime. These functions should be unified anyways.
 */

function extractLinksFromText(text) {
    var regEx = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
    return text.match(regEx);
}

function getRandomColor() {
    return "hsla(" + getRandomInt(80, 300) + ", 60%, 50%, 1)";
}

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function truncateString(str, n) {
    return (str.length > n) ? str.substr(0, n - 1) + '...' : str;
}

function timeSince(input) {
    var date = new Date(input * 1000);
    var seconds = Math.floor((new Date() - date) / 1000);
    var interval = Math.floor(seconds / 31536000);

    if (interval > 1) {
        return interval + " years";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval > 1) {
        return interval + " months";
    }
    interval = Math.floor(seconds / 86400);
    if (interval > 1) {
        return interval + " days";
    }
    interval = Math.floor(seconds / 3600);
    if (interval > 1) {
        return interval + " hours";
    }
    interval = Math.floor(seconds / 60);
    if (interval > 1) {
        return interval + " minutes";
    }
    return Math.floor(seconds) + " seconds";
}

function timeSinceDate(date) {
    var seconds = Math.floor((new Date() - date) / 1000);
    var interval = Math.floor(seconds / 31536000);

    if (interval > 1) {
        return interval + " years";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval > 1) {
        return interval + " months";
    }
    interval = Math.floor(seconds / 86400);
    if (interval > 1) {
        return interval + " days";
    }
    interval = Math.floor(seconds / 3600);
    if (interval > 1) {
        return interval + " hours";
    }
    interval = Math.floor(seconds / 60);
    if (interval > 1) {
        return interval + " minutes";
    }
    return Math.floor(seconds) + " seconds";
}

function getRating(current, maximum) {

    var decimalRate = current / maximum;

    if (decimalRate < 0.1) {
        return 'F'
    } else if (decimalRate < 0.2) {
        return 'E'
    } else if (decimalRate < 0.3) {
        return 'D'
    } else if (decimalRate < 0.4) {
        return 'C'
    } else if (decimalRate < 0.6) {
        return 'B'
    } else if (decimalRate < 0.85) {
        return 'A'
    } else if (decimalRate <= 1) {
        return 'S'
    } else {
        return false
    }
}

function detectUrl(inputUrl, inputOptions, callback, returnRaw) {

    try {
        var parseUrl = new URL(inputUrl);
    } catch (err) {
        return "error";
    }

    var parseUrlHostSplit = parseUrl.host.split('.');
    parseUrl.pureHost = parseUrlHostSplit[parseUrlHostSplit.length - 2];

    var parseImage = {
        rawUrl: inputUrl,
        title: inputOptions.title || "",
        author: inputOptions.author || "",
        score: inputOptions.score || "",
        age: inputOptions.age || "",
        thumbUrl: inputOptions.thumbUrl || "",
        access: inputOptions.access || "",
        extended: inputOptions.extended || false
    };

    // Slimg Handling
    if (parseUrl.host === 'sli.mg' || parseUrl.host === 'i.sli.mg') {
        var pathArray = parseUrl.pathname.split("/").filter(function (n) {
                return n !== ""
            }),
            fragment = pathArray[pathArray.length - 1],
            fragmentArray = fragment.split(".");

        // Case i.sli.mg.com/ABCDE.gifv

        if (fragmentArray[fragmentArray.length - 1] === "gifv") {
            var imgurCode = fragmentArray[0];

            parseImage.contentType = 2;
            parseImage.posterUrl = "https://i.sli.mg/" + imgurCode + "l.jpg";
            parseImage.webmUrl = parseImage.downloadUrl = "https://i.sli.mg/" + imgurCode + ".webm";
            parseImage.mp4Url = "https://i.sli.mg/" + imgurCode + ".mp4";
        }

        // Case i.sli.mg/ABCDE.xyz

        else if (pathArray.length === 1 && fragmentArray.length === 2) {

            if (fragmentArray[1] === "webm" || fragmentArray[1] === "mp4") {

                var slimgCode = fragmentArray[0];

                parseImage.contentType = 2;
                parseImage.posterUrl = "https://i.sli.mg/" + slimgCode + "l.jpg";
                parseImage.webmUrl = parseImage.downloadUrl = "https://i.sli.mg/" + imgurCode + ".webm";
                parseImage.mp4Url = "https://i.sli.mg/" + slimgCode + ".mp4";

            } else {
                parseImage.imageUrl = parseImage.downloadUrl = "https://i.sli.mg/" + fragment;
            }


        }

        // Case sli.mg/r/sub/ABCDE
        // Case sli.mg/ABCDE

        else if (pathArray[0] === "r" || pathArray.length === 1) {

            // Use .jpg as a universal ending (browsers display any image anyway)
            fragment += ".jpg";

            parseImage.imageUrl = parseImage.downloadUrl = "https://i.sli.mg/" + fragment;

        }

        else return "error";
    }

    // Imgur Handling
    else if (parseUrl.host === 'i.imgur.com' || parseUrl.host === 'imgur.com' || parseUrl.host === 'm.imgur.com') {

        var pathArray = parseUrl.pathname.split("/").filter(function (n) {
                return n !== ""
            }),
            fragment = pathArray[pathArray.length - 1],
            fragmentArray = fragment.split(".");

        // Case i.imgur.com/ABCDE.gifv

        if (fragmentArray[fragmentArray.length - 1] === "gifv") {
            var imgurCode = fragmentArray[0];

            parseImage.contentType = 2;
            parseImage.posterUrl = "https://i.imgur.com/" + imgurCode + "l.jpg";
            parseImage.fetchType = "imgurgifv";
            parseImage.fetchData = imgurCode;
            parseImage.needsFetch = true;
        }

        // Case imgur.com/ABCDE&ABCDE&ABCDE

        else if (~fragment.indexOf("&amp;")) {

            var imgurCodesArray = fragment.split('&amp;');

            parseImage.fetchType = "imguralbum";
            parseImage.fetchData = imgurCodesArray[0];
            parseImage.imageUrl = parseImage.downloadUrl = "https://i.imgur.com/" + imgurCodesArray[0] + ".jpg";
            parseImage.albumArray = imgurCodesArray.reverse();

        }

        // Case imgur.com/ABDDE,ABDDE,ABCDE

        else if (~fragment.indexOf(",")) {

            var imgurCodesArray = fragment.split(',');

            parseImage.fetchType = "imguralbum";
            parseImage.fetchData = imgurCodesArray[0];
            parseImage.imageUrl = parseImage.downloadUrl = "https://i.imgur.com/" + imgurCodesArray[0] + ".jpg";
            parseImage.albumArray = imgurCodesArray.reverse();
        }

        // Case imgur.com/a/ABCDE

        else if (pathArray[0] === "a") {

            parseImage.needsFetch = true;
            parseImage.fetchType = "imguralbum";
            parseImage.fetchData = fragment;

        }

        // Case i.imgur.com/ABCDE.xyz

        else if (pathArray.length === 1 && fragmentArray.length === 2) {

            if (fragmentArray[1] === "webm" || fragmentArray[1] === "mp4") {
                var imgurCode = fragmentArray[0];

                parseImage.contentType = 2;
                parseImage.posterUrl = "https://i.imgur.com/" + imgurCode + "l.jpg";
                parseImage.webmUrl = parseImage.downloadUrl = "https://i.imgur.com/" + imgurCode + ".webm";
                parseImage.mp4Url = "https://i.imgur.com/" + imgurCode + ".mp4";
            } else {
                parseImage.imageUrl = parseImage.downloadUrl = "https://i.imgur.com/" + fragment;
            }


        }

        // Case imgur.com/r/sub/ABCDE
        // Case imgur.com/ABCDE

        else if (pathArray[0] === "r" || pathArray.length === 1) {

            // Use .jpg as a universal ending (browsers display any image anyway)
            fragment += ".jpg";

            parseImage.imageUrl = parseImage.downloadUrl = "https://i.imgur.com/" + fragment;

        }

        else return "error";

    }

    //Gfycat Handling
    else if (parseUrl.pureHost == "gfycat") {
        var rawUrlSplit = inputUrl.split('/');
        var gfycatCode = rawUrlSplit[rawUrlSplit.length - 1].replace('.mp4', '').replace('.webm', '');

        parseImage.contentType = 2;
        parseImage.needsFetch = true;
        parseImage.fetchType = "gfycat";
        parseImage.fetchData = gfycatCode;
    }

    // Deviantart Handling
    else if (~parseUrl.host.indexOf("deviantart")) {
        parseImage.needsFetch = true;
        parseImage.fetchType = "deviantart";
        parseImage.fetchData = inputUrl;
    }

    // Local Blob Handling
    else if (inputUrl.substr(5, 10) == "blob:null/") {
        if (inputUrl.substr(0, 5) == "image") {
            parseImage.imageUrl = inputUrl.substr(5);

            checkImage(inputUrl.substr(5), function (blobResult) {
                if (!blobResult) {
                    callback("deadblob")
                }
            });
        } else if (inputUrl.substr(0, 5) == "video") {

            parseImage.contentType = 2;
            parseImage.webmUrl = inputUrl.substr(5);

        }
    }

    // Check for Hotlink
    else if (parseUrl.pathname.split('.').length - 1) {
        var urlExtensionSplit = parseUrl.pathname.split('.');
        var urlExtension = urlExtensionSplit[urlExtensionSplit.length - 1].toLowerCase();

        if (urlExtension == 'jpg' || urlExtension == 'jpeg' || urlExtension == 'png' || urlExtension == 'gif') {
            parseImage.imageUrl = inputUrl;
        } else if (urlExtension == 'webm' || urlExtension == 'mp4') {
            parseImage.contentType = 2;
            parseImage.webmUrl = inputUrl;
        } else {
            return "error";
        }

        parseImage.downloadUrl = inputUrl;
    }

    // Nothing worked
    else return "error";

    return parseImage;
}